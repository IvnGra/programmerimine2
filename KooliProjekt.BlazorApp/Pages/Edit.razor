@page "/create"
@page "/edit/{Id:int}"
@using PublicApi.Api
@using System.ComponentModel.DataAnnotations
@inject IApiClient apiClient
@inject NavigationManager NavManager
<h3>@title</h3>

<!-- Debug info - remove after checking -->
@if (!string.IsNullOrEmpty(debugInfo))
{
    <div class="alert alert-info">
        <h5>Debug Info (remove after checking):</h5>
        <pre>@debugInfo</pre>
    </div>
}

<EditForm EditContext="@editContext" OnValidSubmit="@FormSubmitted">
    <DataAnnotationsValidator />
    <ValidationSummary />
    <div class="form-group row">
        <label for="title" class="col-sm-2 col-form-label">Name</label>
        <div class="col-sm-10">
            <InputText id="title" class="form-control" placeholder="Name" @bind-Value="user.Name" />
            <ValidationMessage For="@(() => user.Name)" />
        </div>
    </div>
    <div class="form-group row" style="margin-top:20px">
        <label class="col-sm-2 col-form-label"></label>
        <div class="col-sm-10">
            <button type="submit" class="btn btn-primary">Save</button>
        </div>
    </div>
</EditForm>
@code {
    [Parameter]
    public int Id { get; set; }
    private User user = new User();
    private EditContext? editContext;
    private ValidationMessageStore? messageStore;
    private string title = "Edit";
    private string debugInfo = ""; // Remove after debugging

    protected override async Task OnInitializedAsync()
    {
        editContext = new EditContext(user);
        messageStore = new ValidationMessageStore(editContext);
        if (Id == 0)
        {
            title = "Add";
            return;
        }

        try
        {
            var apiResult = await apiClient.Get<User>(Id);

            // DEBUG: Check what properties the API Result has
            var properties = apiResult.GetType().GetProperties()
                .Select(p => $"{p.Name}: {p.PropertyType.Name}")
                .ToArray();
            debugInfo = "API Result Properties:\n" + string.Join("\n", properties);

            // Try common property patterns
            bool hasErrors = false;
            var errorMessages = new Dictionary<string, string>();

            // Check for common error properties
            var resultType = apiResult.GetType();

            // Pattern 1: IsSuccess property
            var isSuccessProp = resultType.GetProperty("IsSuccess");
            if (isSuccessProp != null)
            {
                var isSuccess = (bool)isSuccessProp.GetValue(apiResult);
                hasErrors = !isSuccess;
                debugInfo += $"\nIsSuccess: {isSuccess}";
            }

            // Pattern 2: ErrorMessage property
            var errorMsgProp = resultType.GetProperty("ErrorMessage");
            if (errorMsgProp != null)
            {
                var errorMsg = errorMsgProp.GetValue(apiResult)?.ToString();
                if (!string.IsNullOrEmpty(errorMsg))
                {
                    hasErrors = true;
                    errorMessages["General"] = errorMsg;
                }
                debugInfo += $"\nErrorMessage: {errorMsg}";
            }

            // Pattern 3: Errors property (might be different type)
            var errorsProp = resultType.GetProperty("Errors");
            if (errorsProp != null)
            {
                var errors = errorsProp.GetValue(apiResult);
                debugInfo += $"\nErrors type: {errorsProp.PropertyType.Name}";
                debugInfo += $"\nErrors value: {errors}";
            }

            if (hasErrors)
            {
                AddValidationErrors(errorMessages);
                return;
            }

            user = apiResult.Value;
            editContext = new EditContext(user);
            messageStore = new ValidationMessageStore(editContext);
        }
        catch (Exception ex)
        {
            debugInfo += $"\nException: {ex.Message}";
        }
    }

    private async Task FormSubmitted()
    {
        try
        {
            var apiResult = await apiClient.Save(user);

            // Same debugging approach for Save
            var resultType = apiResult.GetType();
            bool hasErrors = false;
            var errorMessages = new Dictionary<string, string>();

            // Check IsSuccess
            var isSuccessProp = resultType.GetProperty("IsSuccess");
            if (isSuccessProp != null)
            {
                var isSuccess = (bool)isSuccessProp.GetValue(apiResult);
                hasErrors = !isSuccess;
            }

            // Check ErrorMessage
            var errorMsgProp = resultType.GetProperty("ErrorMessage");
            if (errorMsgProp != null)
            {
                var errorMsg = errorMsgProp.GetValue(apiResult)?.ToString();
                if (!string.IsNullOrEmpty(errorMsg))
                {
                    hasErrors = true;
                    errorMessages["General"] = errorMsg;
                }
            }

            if (hasErrors)
            {
                AddValidationErrors(errorMessages);
                return;
            }

            NavManager.NavigateTo("/");
        }
        catch (Exception ex)
        {
            debugInfo += $"\nSave Exception: {ex.Message}";
        }
    }

    private void AddValidationErrors(Dictionary<string, string> errors)
    {
        if (errors == null || !errors.Any())
            return;

        foreach (var error in errors)
        {
            var fieldId = new FieldIdentifier(user, error.Key == "General" ? nameof(user.Name) : error.Key);
            messageStore?.Add(fieldId, error.Value);
        }
        editContext?.NotifyValidationStateChanged();
    }

    public class User
    {
        public int Id { get; set; }
        [Required(ErrorMessage = "Name is required")]
        public string Name { get; set; } = string.Empty;
    }
}